---
title: 'CSCI E-63C: Final Exam'
output:
  html_document:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(glmnet)
library(leaps)
library(randomForest)
library(MASS)
library(class)
library(e1071)
library(dummies)
library(keras)
library(tidyverse)
```

# Preface

For the final exam/project we will develop classification models using several approaches and compare their performance on a new dataset that is a subset of one of the datasets used in machine learning common task framework (CTF) competitions.  A copy of it split into training (`final-data-train.csv`, with outcome `yn` available) and test (`final-data-test.csv`, stripped of the outcome, for prediction purposes only) datasets is available on our course website in Canvas as a zip-archive of all associated files.

Please notice, that at the end of this final exam/project you will be asked, in addition to the Rmarkdown and HTML files, to also make predictions for the observations in the *test* (not training!) dataset and upload them into Canvas as well.  The expected format for the file with predictions for test dataset is two columns of comma-separated values, one row per observation in *test* dataset, first column -- the observation identifier (column `id` in test dataset) and the second column -- your best model predictions for each observation in the *test* dataset as yes/no indicator.  To illustrate expected format the zip archive contains also a couple of examples of test predictions in this format for your reference as well (`predictions-*.csv` files in `predictions-examples` sub-folder in zip-archive).

One more time, to iterate and emphasize, please notice that this time your submission must consist of the following *three* (not just two, Rmd+html, as usual) items:

* Rmarkdown *.Rmd file with all the calculations you want to receive credit for,
* HTML version of the output generated by your *.Rmd file, and
* **predictions** for the **test** dataset in comma-separated values (CSV) format (file name must have *.csv extension for the file to load in Canvas)

The teaching team invites you to load your predictions (just predictions, just for the test dataset according to the file format shown in the sample files in the zip-archive) into Canvas repeatedly as you work on your models and improve them over the course of this week.  At least daily (or more frequently as we see fit) we will download predictions loaded by everyone by that time and compile a leaderboard in html format of all of them sorted by their accuracy as compared to the true values of the outcome for the test dataset (along with their sensitivity, specificity, etc.).  This list will be made available on our course website in Canvas for everyone in this class in order to see how the performance of their models compares across the rest of the models built by other students in the class.  The first version of the leaderboard posted on the course website at the time when final exam is made available starts with predictions made by those few example files provided in the zip-archive (coin flip, majority vote, etc. -- what do you think Charlie Brown is using to make the predictions?).  Those should be pretty easy to improve upon.

It is 100% up to you whether you want to upload your model predictions over the course of this week, how frequently you want to do it and what you want its results to be called in the leaderboard posted for everyone in the class to see.  We will use the name of the 2nd column in the file with predictions (the one containing yes/no values, not the numerical ids of the observations) as the model name listed in the leaderboard.  If you prefer not to use your name, choose something else instead, sufficiently unique so that it is easier for you to spot your result among all others.  Once again, please check out sample files of dull (majority vote, coin flip, etc.) predictions we have made available and consider how they show up in the leaderboard html file already posted on Canvas website.  Once you are done with final you are expected to load predictions from your best model into Canvas -- that is part of your points total as explained below.

Lastly, the size of this dataset can make some of the modeling techniques run slower than what we were typically encountering in this class.  You may find it helpful to do some of the exploration and model tuning on multiple random samples of smaller size as you decide on useful ranges of parameters/modeling choices, and then only perform a final run of fully debugged and working code on the full dataset.  Please see also the afterword below on the computational demands of this problem set.

``` {r metricFunctions}
calcAcc <- function (cm) {
  sum(diag(cm)) / sum(cm)
}

calcSpecificity <- function (cm) {
  cm[1, 1] / sum(cm[, 1])
}

calcSensitivity <- function (cm) {
  if (ncol(cm) == 2) {
    cm[2, 2] / sum(cm[, 2])
  }
  else {
    0
  }
}
```

# Problem 1: univariate and unsupervised analysis (20 points)

Download and read training and test data into R and prepare graphical and numerical summaries of it: e.g. histograms of continuous attributes, contingency tables of categorical variables, scatterplots of continuous attributes with some of the categorical variables indicated by color/symbol shape, etc.  Whatever you find helpful to think about properties of the data you are about to start using for fitting classification models.

As it is often the case for such contests, the atributes in the dataset are blinded in the sense that no information is available about what those are or what their values mean.  The only information available is that the attribute `yn` is the outcome to be modeled and the attribute `id` is the unique numerical identifier for each observation.  Some of the remaining attributes are clearly categorical (those that are character valued) and some rather obviously continuous (those with numerical values with large number of unique values).  For several of them it is less clear whether it is best to treat them as continuous or categorical -- e.g. their values are numerical but there are relatively few unique values with many observations taking the same value, so that they arguably could be treated as continuous or categorical.  Please idenify them, reflect on how you prefer to handle them and describe this in your own words.

Perform principal components analysis of this data (do you need to scale it prior to that? how would you represent multilevel categorical attributes to be used as inputs for PCA?) and plot observations in the space of the first few principal components indicating levels of some of the categorical attributes of your choosing by the color/shape of the symbol.  Perform univariate assessment of associations between outcome we will be modeling and each of the attributes (e.g. t-test or logistic regression for continuous attributes, contingency tables/Fisher exact test/$\chi^2$ test for categorical attributes).  Summarize your observations from these assessments: does it appear that there are predictors associated with the outcome `yn` univariately? Which predictors seem to be more/less relevant?

``` {r loadData}
rawData <- read_csv("final-data-train.csv") %>% mutate_if(is.character, as.factor)
```

``` {r summarizeData}
head(rawData)
summary(rawData)
```


``` {r numericPairsPlot}
rawData %>% select_if(is.numeric) %>% select(-id) %>% pairs(col = c("black", "red")[rawData$yn])
```

Columns ag and cg seem to have pretty good correlation to the target. Something interesting is happening in coumn cl, where many rows have value zero and non-zero quantities seem to be between 1 and about 1.7. It seems like column hw would benefit from log transformation. I don't think it would benefit from conversion to categorical though, there seems to be some amount of correlation between the value and the target.

``` {r clCor}
rawData %>% select_if(is.numeric) %>% select(-id) %>% filter(cl != 0) %>% cor() %>% .[,"cl"]
```

``` {r clFix}
clLRFit <- glm(cl ~ cg + ag, data = filter(rawData, cl != 0))
newcl <- predict(clLRFit, newdata = filter(rawData, cl == 0))

summary(clLRFit)
plot(clLRFit)
```

``` {r catContingencyTable}
for (catRow in select_if(rawData, is.factor)) {
  print(table(rawData$yn, catRow))
}
```

First thing worth noting is that target no is about three times more common than a target yes. Feature se seems to have pretty good correlation and is only two levels. It seems also that most target no samples have eg of e2, which may be helpful. There may be some correlations with the other factors but it's difficult to tell with both the class imbalance and the higher number of factors.


``` {r makeTrainData}
trainData <- rawData %>%
  mutate(
    e2 = eg == "e2",
    clz = cl == 0,
    hw = log(hw + 1e-6)
    )
trainData[trainData$cl == 0, "cl"] <- newcl

trainDataDummies <- as.tibble(dummy.data.frame(as.data.frame(select(trainData, -yn)))) %>%
  bind_cols(select(trainData, yn))
```

``` {r pca}
pcaFit <- prcomp(select(trainDataDummies, -yn), scale. = TRUE)
plot(pcaFit)
```

``` {r pcaPlot}
biplot(pcaFit, pc.biplot = TRUE)
```

``` {r plotCategoriesWithPCA}
factorColNames <- colnames(select_if(trainData, is.factor))

for (factorColName in factorColNames) {
  pairs(pcaFit$x[, 1:3], col = trainData[[factorColName]])
  title(factorColName)
}
```

``` {r xvalSingleVar}
k <- 10
kfInd <- sample(rep(c(1:k),length.out=nrow(trainData)))
xvalResultsLRSV <- tibble()

numericColNames <- colnames(select(select_if(trainData, is.numeric), -id))

for (fold in 1:k) {
  for (numericColName in numericColNames) {
    singleVarData <- bind_cols(
      var = trainData[, numericColName],
      yn = trainData[, "yn"]
    ) %>% mutate(yn = as.numeric(yn) - 1)
    trainDataFit <- singleVarData[kfInd != fold, ]
    trainDataVal <- singleVarData[kfInd == fold, ]
  
    lrFit <- glm(
      yn ~ ., 
      data = trainDataFit)
    
    lrPredict <- predict(lrFit, newdata = trainDataVal, type = "response")
    lrCM <- table(trainDataVal$yn, round(lrPredict))
  
    xvalResultsLRSV <- rbind(xvalResultsLRSV, tibble(
      fold = fold,
      acc = calcAcc(lrCM),
      sens = calcSensitivity(lrCM),
      spec = calcSpecificity(lrCM),
      model = paste("lr", numericColName, sep = "-")
    ))
  }
}
```

``` {r plotLRSVXval}
xvalResultsLRSV %>% gather(key = metric, value = value, -c(fold, model)) %>% 
  ggplot(aes(x = model, y = value, col = metric)) + geom_boxplot()
```


# Problem 2: logistic regression (20 points)

Develop logistic regression model of the outcome `yn` as a function of multiple predictors in the model.  Which variables are significantly associated with the outcome?  Test model performance on multiple splits of data into training and test subsets and summarize it in terms of accuracy/error/sensitivity/specificity.

``` {r testNumericCorrelation}
trainData %>% 
  select_if(is.numeric) %>% select(-id) %>% cbind(yn = as.numeric(trainData$yn)) %>% 
  cor()
```

Decent correlation with yn and features cg, ag, and nc. Some of these features are also fairly well correlated with each other, especially cg and ag.

``` {r fitSingleLR}
lrFit <- glm(
  yn ~ cg + fw + cl + hw + nc + ag + e2 + se + clz, 
  data = trainData, family = binomial)

summary(lrFit)
```

``` {r xvalLR}
k <- 10
kfInd <- sample(rep(c(1:k),length.out=nrow(trainData)))
xvalResultsLR <- tibble()

for (fold in 1:k) {
  trainDataFit <- trainData[kfInd != fold, ]
  trainDataVal <- trainData[kfInd == fold, ]

  lrFit <- glm(
    yn ~ cg + fw + cl + hw + nc + ag + e2 + se + clz, 
    data = trainDataFit, family = binomial)
  
  lrPredict <- predict(lrFit, newdata = trainDataVal, type = "response")
  lrCM <- table(trainDataVal$yn, round(lrPredict))

  xvalResultsLR <- rbind(xvalResultsLR, tibble(
    fold = fold,
    acc = calcAcc(lrCM),
    sens = calcSensitivity(lrCM),
    spec = calcSpecificity(lrCM),
    model = "lr"
  ))
}
```

``` {r plotLRXval}
xvalResultsLR %>% gather(key = metric, value = value, -c(fold, model)) %>% 
  ggplot(aes(x = model, y = value, col = metric)) + geom_boxplot()
```


## Extra points problem: interaction terms (5 extra points)

Assess the impact/significance of pairwise interaction terms for all pairwise combinations of covariates used in the model and report the top ten that most significantly improve model fit.

``` {r generateInteractionTerms}
numSubsetData <- bind_cols(
  select(trainData, yn),
  select_if(trainData, is.numeric),
) %>% select(-id)

lmFit <- glm(yn ~ . + .*., data = numSubsetData, family = binomial)
summary(lmFit)
```

```{r predictRegsubsets}
# taken from homework 5, which was in turn taken from ISLR lab 6.5.3
predict.regsubsets <- function (object, newdata, id, ...){
  form=as.formula(object$call [[2]])
  mat=model.matrix(form,newdata)
  coefi=coef(object,id=id)
  xvars=names (coefi)
  mat[,xvars] %*% coefi
}
```

``` {r interactOptimalSet}
selectMethods <- c("exhaustive", "backward", "forward", "seqrep")
fitMetrics <- c("rsq","rss","adjr2","bic")
nVars <- ncol(numSubsetData) - 1 + ncol(combn(colnames(select(numSubsetData, -yn)), 2))
selectWhichInteract <- NULL
selectMetricsInteract <- NULL

for (method in selectMethods) {
  # fit using each method of determining subsets and save summary of results
  selectFit <- regsubsets(yn ~ . + .*., numSubsetData, method=method, nvmax=nVars)
  selectSummary <- summary(selectFit)
  
  # extract which features are used for each number of variables and save with method
  selectWhich <- as.tibble(selectSummary$which)
  selectWhich$method <- method
  selectWhich$vars <- 1:nVars
  selectWhichInteract <- rbind(selectWhichInteract, selectWhich)
  
  # extract fit quality metrics for each number of variables and save with method
  selectMetrics <- as.tibble(selectSummary[fitMetrics])
  selectMetrics$method <- method
  selectMetrics$vars <- 1:nVars
  selectMetricsInteract <- rbind(selectMetricsInteract, selectMetrics)
}

selectMetricsInteract <- selectMetricsInteract %>% 
  gather(key = metric, value = value, fitMetrics)
```

``` {r interactPlotOptimalMetrics}
ggplot(selectMetricsInteract, aes(x = vars,y = value,shape = method,colour = method)) + 
  geom_path() + 
  geom_point() + 
  facet_wrap(~metric,scales="free") + 
  theme(legend.position="top")
```

``` {r interactPlotSelectedVars}
plotWhich <- selectWhichInteract %>% 
  gather(key = param, value = selected, -c(method, vars))
ggplot(plotWhich, aes(x = vars, y = param, fill = selected)) + 
  geom_tile() + 
  facet_wrap(~method)
```

``` {r showBestSelectedVars}
selectWhichInteract %>% 
  gather(key = param, value = selected, -c(method, vars)) %>% 
  group_by(param) %>% 
  summarize(sum = sum(selected)) %>%
  arrange(desc(sum)) %>%
  head(15) %>%
  ggplot(aes(x = fct_reorder(param, sum, .desc = TRUE), y = sum)) + geom_col()
```

``` {r fitSingleIntLR}
lrFit <- glm(
  yn ~ cg + fw + cl + hw + nc + ag + e2 + se + cl*nc + cg*ag + cl*ag, 
  data = trainData, family = binomial)

summary(lrFit)
```

``` {r xvalIntLR}
k <- 10
kfInd <- sample(rep(c(1:k),length.out=nrow(trainData)))
xvalResultsLRInt <- tibble()

for (fold in 1:k) {
  trainDataFit <- trainData[kfInd != fold, ]
  trainDataVal <- trainData[kfInd == fold, ]

  lrFit <- glm(
    yn ~ cg + fw + cl + hw + nc + ag + e2 + se + clz + cl*nc + cg*ag + cl*ag, 
    data = trainDataFit, family = binomial)
  
  lrPredict <- predict(lrFit, newdata = trainDataVal, type = "response")
  lrCM <- table(trainDataVal$yn, round(lrPredict))

  xvalResultsLRInt <- rbind(xvalResultsLRInt, tibble(
    fold = fold,
    acc = calcAcc(lrCM),
    sens = calcSensitivity(lrCM),
    spec = calcSpecificity(lrCM),
    model = "lr-int"
  ))
}
```

``` {r plotIntLRXval}
xvalResultsLRInt %>% gather(key = metric, value = value, -c(fold, model)) %>% 
  ggplot(aes(x = model, y = value, col = metric)) + geom_boxplot()
```


# Problem 3: linear discriminant analysis (15 points)

Fit linear discriminant analysis model of the outcome `yn` as a function of the rest of covariates in the dataset.  Feel free to decide whether you want to use all of them or a subset of those.  Test resulting model performance on multiple splits of the data into training and test subsets, summarize it in terms of accuracy/error/sensitivity/specificity and compare them to those obtained for logistic regression.

``` {r xvalLDA}
k <- 10
kfInd <- sample(rep(c(1:k),length.out=nrow(trainData)))
xvalResultsLDA <- tibble()

for (fold in 1:k) {
  trainDataFit <- trainData[kfInd != fold, ]
  trainDataVal <- trainData[kfInd == fold, ]

  ldaFit <- lda(
    yn ~ cg + fw + cl + hw + nc + ag + e2 + se, 
    data = trainDataFit)
  
  ldaPredict <- predict(ldaFit, newdata = trainDataVal)
  ldaCM <- table(trainDataVal$yn, as.numeric(ldaPredict$x > 0))

  xvalResultsLDA <- rbind(xvalResultsLDA, tibble(
    fold = fold,
    acc = calcAcc(ldaCM),
    sens = calcSensitivity(ldaCM),
    spec = calcSpecificity(ldaCM),
    model = "lda"
  ))
}
```

``` {r plotLDAXval}
xvalResultsLDA %>% gather(key = metric, value = value, -c(fold, model)) %>% 
  ggplot(aes(x = model, y = value, col = metric)) + geom_boxplot()
```

## Extra points problem: quadratic discriminant analysis (5 extra points)

In our experience attempting to fit quadratic discriminant analysis model of the categorical outcome `yn` on this data results in a rank deficiency related error. Determine on how to correct this error and report resulting model training and test error/accuracy/etc. and how it compares to LDA and logistic regression above. 

``` {r xvalQDA}
k <- 10
kfInd <- sample(rep(c(1:k),length.out=nrow(trainData)))
xvalResultsQDA <- tibble()

for (fold in 1:k) {
  trainDataFit <- trainData[kfInd != fold, ]
  trainDataVal <- trainData[kfInd == fold, ]

  qdaFit <- qda(
    yn ~ cg + fw + cl + hw + nc + ag + e2 + se, 
    data = trainDataFit)
  
  qdaPredict <- predict(qdaFit, newdata = trainDataVal)
  qdaCM <- table(trainDataVal$yn, qdaPredict$class)

  xvalResultsQDA <- rbind(xvalResultsQDA, tibble(
    fold = fold,
    acc = calcAcc(qdaCM),
    sens = calcSensitivity(qdaCM),
    spec = calcSpecificity(qdaCM),
    model = "qda"
  ))
}
```

``` {r plotQDAXval}
xvalResultsQDA %>% gather(key = metric, value = value, -c(fold, model)) %>% 
  ggplot(aes(x = model, y = value, col = metric)) + geom_boxplot()
```

# Problem 4: random forest (15 points)

Develop random forest model of outcome `yn`. Present variable importance plots and comment on relative importance of different attributes in the model.  Did attributes showing up as more important in random forest model also appear as significantly associated with the outcome by logistic regression?  Test model performance on multiple splits of data into training and test subsets, compare test and out-of-bag error estimates, summarize model performance in terms of accuracy/error/sensitivity/specificity and compare to the performance of logistic regression and LDA models above.

``` {r tryRF}
rfFit <- randomForest(select(trainData, -yn), trainData$yn)
```

``` {r plotTopRFVars}
rfFit$importance %>% as.tibble(rownames = "feature") %>%
  ggplot(aes(x = fct_reorder(feature, MeanDecreaseGini, .desc = TRUE), y = MeanDecreaseGini)) + 
  geom_col()
```

``` {r xvalRF}
k <- 10
kfInd <- sample(rep(c(1:k),length.out=nrow(trainData)))
xvalResultsRF <- tibble()

for (fold in 1:k) {
  trainDataFit <- trainData[kfInd != fold, ]
  trainDataVal <- trainData[kfInd == fold, ]

  rfFit <- randomForest(select(trainDataFit, -yn), trainDataFit$yn)
  
  rfPredict <- predict(rfFit, newdata = select(trainDataVal, -yn))
  rfCM <- table(trainDataVal$yn, rfPredict)

  xvalResultsRF <- rbind(xvalResultsRF, tibble(
    fold = fold,
    acc = calcAcc(rfCM),
    sens = calcSensitivity(rfCM),
    spec = calcSpecificity(rfCM),
    model = "rf"
  ))
}
```

``` {r plotRFXval}
xvalResultsRF %>% gather(key = metric, value = value, -c(fold, model)) %>% 
  ggplot(aes(x = model, y = value, col = metric)) + geom_boxplot()
```

# Problem 5: SVM (20 points)

Develop SVM model of categorical outcome `yn` deciding on the choice of kernel, cost, etc. that appear to yield better performance.  Test model performance on multiple splits of data into training and test subsets, summarize model performance in terms of accuracy/error/sensitivity/specificity and compare to the performance of the rest of the models developed above (logistic regression, LDA, random forest).

``` {r tuneSVM}
costs <- c(1, 3, 5) #c(0.1, 0.3, 0.5, 1, 3, 10, 30, 100)
#gammas <- c(0.01, 0.1) #c(0.01, 0.02, 0.05, 0.1, 0.2)

tune.out <- tune(svm, yn ~ cg + fw + cl + hw + nc + ag + e2 + se, data = trainData, 
                 kernel = "linear", scale = TRUE, 
                 ranges = list(cost = costs))

```

``` {r tuneSVMSummary}
summary(tune.out)
```

``` {r xvalSVM}
k <- 10
kfInd <- sample(rep(c(1:k),length.out=nrow(trainData)))
xvalResultsSVM <- tibble()

for (fold in 1:k) {
  trainDataFit <- trainData[kfInd != fold, ]
  trainDataVal <- trainData[kfInd == fold, ]

  svmFit <- svm(yn ~ cg + fw + cl + hw + nc + ag + e2 + se, 
                data = trainDataFit, kernel = "linear", scale = TRUE,
                cost = 3)
  
  svmPredict <- predict(svmFit, trainDataVal)
  svmCM <- table(trainDataVal$yn, svmPredict)

  xvalResultsSVM <- rbind(xvalResultsSVM, tibble(
    fold = fold,
    acc = calcAcc(svmCM),
    sens = calcSensitivity(svmCM),
    spec = calcSpecificity(svmCM),
    model = "lin-svm"
  ))
}
```

``` {r plotSVMXval}
xvalResultsSVM %>% gather(key = metric, value = value, -c(fold, model)) %>% 
  ggplot(aes(x = model, y = value, col = metric)) + geom_boxplot()
```

# Extra 10 points: neural network model

Experiment with fitting neural network models of categorical outcome `yn` for this data and evaluate their performance on different splits of the data into training and test. Compare model performance to that for the rest of classifiers developed above.

``` {r resampleData}
yesRows <- moreData %>% filter(yn == "yes") 
resampData <- yesRows %>% 
  .[sample(1:nrow(yesRows), nrow(moreData) - 2 * nrow(yesRows), replace=TRUE), ] %>% 
  bind_rows(moreData) %>% 
  mutate(ynn = as.numeric(yn) - 1) %>% 
  select_if(negate(is.factor)) %>% 
  select(-id)

resampData %>% count(ynn)
```

``` {r buildNeuralNet}
model <- keras_model_sequential()
model %>% 
  layer_dense(units = 128, activation = "relu", input_shape = ncol(resampData) - 1, name = "dense_1") %>%
  layer_dropout(rate = 0.3, name = "dropout_1") %>%
  layer_dense(units = 32, activation = "relu", name = "dense_2") %>%
  layer_dropout(rate = 0.3, name = "dropout_2") %>%
  layer_dense(units = 1, activation = "sigmoid", name = "dense_final")

summary(model)
```

``` {r tryNeuralNet}
model %>% compile(
  loss = loss_binary_crossentropy,
  optimizer = optimizer_adam(),
  metrics = c('accuracy')
)

history <- model %>% fit(
  x = as.matrix(resampData %>% select(-ynn)), 
  y = as.matrix(resampData %>% select(ynn)), 
  epochs = 50, batch_size = 512, validation_split = 0.2
)
```

``` {r xvalNN}
k <- 10
kfInd <- sample(rep(c(1:k),length.out=nrow(resampData)))
xvalResultsNN <- tibble()

for (fold in 1:k) {
  trainDataFit <- resampData[kfInd != fold, ]
  trainDataVal <- resampData[kfInd == fold, ]
  
  model <- keras_model_sequential()
  model %>% 
    layer_dense(units = 128, activation = "relu", input_shape = ncol(trainDataFit) - 1, name = "dense_1") %>%
    layer_dropout(rate = 0.3, name = "dropout_1") %>%
    layer_dense(units = 32, activation = "relu", name = "dense_2") %>%
    layer_dropout(rate = 0.3, name = "dropout_2") %>%
    layer_dense(units = 1, activation = "sigmoid", name = "dense_final")
  
  model %>% compile(
    loss = loss_binary_crossentropy,
    optimizer = optimizer_adam(),
    metrics = c('accuracy')
  )
  
  history <- model %>% fit(
    x = as.matrix(trainDataFit %>% select(-ynn)), 
    y = as.matrix(trainDataFit %>% select(ynn)), 
    epochs = 50, batch_size = 512, verbose = 0
  )
  
  nnPredict <- model %>% predict_classes(as.matrix(trainDataVal %>% select(-ynn)))
  nnCM <- table(trainDataVal$ynn, nnPredict)

  xvalResultsNN <- rbind(xvalResultsNN, tibble(
    fold = fold,
    acc = calcAcc(nnCM),
    sens = calcSensitivity(nnCM),
    spec = calcSpecificity(nnCM),
    model = "nn"
  ))
}
```

``` {r plotNNXval}
xvalResultsNN %>% gather(key = metric, value = value, -c(fold, model)) %>% 
  ggplot(aes(x = model, y = value, col = metric)) + geom_boxplot()
```

``` {r compareXvalToNN}
xvalResults <- bind_rows(
  xvalResultsLR,
  xvalResultsLRInt,
  xvalResultsLDA,
  xvalResultsQDA,
  xvalResultsRF,
  xvalResultsSVM,
  xvalResultsNN
)

xvalResults %>% gather(key = metric, value = value, -c(fold, model)) %>% 
  ggplot(aes(x = fct_reorder(model, value, .desc = TRUE), y = value, col = metric)) +
  geom_boxplot()
```

# Problem 6: predictions for test dataset  (10 points)

## Problem 6a: compare logistic regression, LDA, random forest and SVM model performance (3 points)

Compare performance of the models developed above (logistic regression, LDA, random forest, SVM) in terms of their accuracy, error and sensitivity/specificity.  Comment on differences and similarities between them.

``` {r compareXval}
xvalResults <- bind_rows(
  xvalResultsLR,
  xvalResultsLRInt,
  xvalResultsLDA,
  xvalResultsQDA,
  xvalResultsRF,
  xvalResultsSVM,
  xvalResultsNN
)

xvalResults %>% gather(key = metric, value = value, -c(fold, model)) %>% 
  ggplot(aes(x = fct_reorder(model, value, .desc = TRUE), y = value, col = metric)) +
  geom_boxplot()
```

## Problem 6b: make predictions for the **test** dataset (3 points)

Decide on the model that performs the best and use it to make predictions for the **test** dataset.  This is the dataset that is provided separately from training data without the outcome `yn` that we are modeling here.  Upload resulting predictions in comma-separated values (CSV) format into the Canvas website.  Please check sample files with test dataset predictions for the expected format of the *.csv file with predictions.

``` {r dataWithInteractions}
moreData <- trainDataDummies %>%
  mutate(
    clnc = cl * nc,
    cgag = cg * ag,
    clag = cl * ag
  )
```

``` {r tryRFM}
rfFit <- randomForest(select(moreData, -yn), moreData$yn)
```

``` {r plotTopRFMVars}
rfFit$importance %>% as.tibble(rownames = "feature") %>% 
  arrange(desc(MeanDecreaseGini)) %>%
  head(20) %>%
  ggplot(aes(x = fct_reorder(feature, MeanDecreaseGini, .desc = TRUE), y = MeanDecreaseGini)) + 
  geom_col()
```

``` {r xvalRFM}
k <- 10
kfInd <- sample(rep(c(1:k),length.out=nrow(moreData)))
xvalResultsRFM <- tibble()

for (fold in 1:k) {
  trainDataFit <- moreData[kfInd != fold, ]
  trainDataVal <- moreData[kfInd == fold, ]

  rfmFit <- randomForest(select(trainDataFit, -yn), trainDataFit$yn)
  
  rfmPredict <- predict(rfmFit, newdata = select(trainDataVal, -yn))
  rfmCM <- table(trainDataVal$yn, rfmPredict)

  xvalResultsRFM <- rbind(xvalResultsRFM, tibble(
    fold = fold,
    acc = calcAcc(rfmCM),
    sens = calcSensitivity(rfmCM),
    spec = calcSpecificity(rfmCM),
    model = "rf-m"
  ))
}
```

``` {r plotRFMXval}
xvalResultsRFM %>% gather(key = metric, value = value, -c(fold, model)) %>% 
  ggplot(aes(x = model, y = value, col = metric)) + geom_boxplot()
```



``` {r compareBestXval}
xvalResults <- bind_rows(
  xvalResultsLR,
  xvalResultsLRInt,
  xvalResultsRF,
  xvalResultsRFM,
  xvalResultsSVM,
  xvalResultsNN
)

xvalResults %>% gather(key = metric, value = value, -c(fold, model)) %>% 
  ggplot(aes(x = fct_reorder(model, value, .desc = TRUE), y = value, col = metric)) +
  geom_boxplot()
```




## Problem 6c: get better than coin flip by 10% (4 points)

This is not really a problem *per se* but rather a criterion we will go by assessing quality of your predictions for the test dataset.  You get these four points if your predictions for **test** dataset are better than those obtained from a fair coin flip (already shown in leaderboard and as examples of the file format for predictions upload) by at least 10% on **all** four metrics shown in the leaderboard (accuracy, sensitivity, specificity and precision).  But then predictions by the coin flip should not be very difficult to improve upon.  


# An afterword on the computational demands of the final exam

Because during previous offerings of this course there were always several posts on piazza regarding how long it takes to fit various classifiers to the final exam dataset we have added this note here.

First of all, we most definitely do *not* expect you to *have* to buy capacity from AWS to complete this assignment. You certainly can if you want to, but this course is not about that and this dataset is really not *that* big to require it. Something reasonable/useful can be accomplished for this data with middle of the road hardware. For instance, knitting of the entire official solution for the final exam on 8Gb RAM machine with two i5-7200u cores takes about an hour using single-threaded R/Rstudio and this includes both extra points problems as well as various assessments of the performance of different models as function of data size and so on.

Second, your solution should not take hours and hours to compile. If it does, it could be that it is attempting to do too much, or something is implemented inefficiently, or just plain incorrectly - it is impossible for us to comment on this until we see the code when we grade it. In general, it is often very prudent to "start small" -- fit your model on a random subset of data small enough for the model fitting call to return immediately, check how model performance (both in terms of error and time it takes to compute) scales with the size of the data you are training it on (as you increase it in size, say, two-fold several times), for tuning start with very coarse grid of parameter values and given those results decide what it right for you, etc.

Lastly, making the decision about what is right for the problem at hand, how much is enough, etc. is inherent in this line of work. If you choose to conduct model tuning on a subset of the data - especially if you have some assessment of how the choice of tuning parameter and test error is affected by the size of training dataset - it could be a very wise choice.  If it is more efficient for you to knit each problem separately, by all means feel free to do that - just remember to submit each .Rmd and HTML file that comprises your entire solution. On that note, if you end up using any of the unorthodox setups for your calculations (e.g. AWS, parallel processing, multiple machines, etc. - none of which are essential for solving it correctly) please be sure that when we grade we have every relevant piece of code available - we won't be able to grade your work if we are not clear about how the results were obtained.

In the end, the final exam asks you to assess performance of several classification technologies on a new dataset, decide on which classifier is the best and use it to make predictions for the test data. It is very much up to you how exactly you want to go about it.  There could be many versions of correct and informative solution for that (as there could be just as many if not more that are completely wrong).

As always, best of luck - we are practically done here!
